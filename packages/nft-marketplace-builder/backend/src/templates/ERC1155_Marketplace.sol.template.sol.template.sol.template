```solidity
// SPDX-License-Identifier: {{LICENSE}}

pragma solidity ^0.8.20;

import "@openzeppelin/contracts/token/ERC1155/ERC1155.sol";
import "@openzeppelin/contracts/token/ERC1155/extensions/ERC1155Supply.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/utils/Strings.sol";
import "@openzeppelin/contracts/interfaces/IERC2981.sol";

/**
 * @title {{COLLECTION_NAME}} (ERC1155 NFT Collection)
 * @dev ERC1155 token contract for the {{COLLECTION_NAME}} ({{COLLECTION_SYMBOL}}) collection.
 * Generated by BlockDeploy (Primex Software - https://primex-software.com).
 *
 * Features:
 *  - ERC1155 Standard with supply tracking.
 *  - Ownable: Contract has an owner with administrative privileges for minting.
 *  - ERC2981: Royalty standard for secondary sales, configured at deployment.
 *  - URI can be set with a base URI and token ID, or per token.
 */
contract {{COLLECTION_CONTRACT_NAME}} is ERC1155, ERC1155Supply, Ownable, IERC2981 {
    
    address private _royaltyRecipient;
    uint96 private _royaltyFraction; // Basis points, e.g., 500 for 5%
    string private _baseURI; // Optional base URI for token metadata

    // Mapping from token ID to specific URI (if not using base URI pattern)
    mapping(uint256 => string) private _tokenURIs;

    /**
     * @dev Constructor that sets the collection name (via base URI), owner,
     *      and royalty information.
     * @param initialOwner_ Address that will own this contract and can mint/manage.
     * @param royaltyRecipient_ Address to receive royalty payments.
     * @param royaltyPercentage_ Royalty percentage in basis points (e.g., 500 for 5%). Max 10000 (100%).
     * @param baseURI_ Base URI for token metadata. Token URI will be baseURI + tokenId.toString() + ".json".
     *                 If an empty string is provided, individual token URIs must be set.
     */
    constructor(
        address initialOwner_,
        address royaltyRecipient_,
        uint96 royaltyPercentage_,
        string memory baseURI_ // Example: "ipfs://CID_METADATA_FOLDER/" or "https://api.example.com/nfts/"
    ) ERC1155("") Ownable(initialOwner_) { // ERC1155's URI is managed by the overridden `uri` function
        require(royaltyRecipient_ != address(0), "ERC2981: Recipient is zero address");
        require(royaltyPercentage_ <= 10000, "ERC2981: Royalty percentage too high");
        _royaltyRecipient = royaltyRecipient_;
        _royaltyFraction = royaltyPercentage_;
        _baseURI = baseURI_;
    }

    /**
     * @dev See {IERC1155MetadataURI-uri}.
     * Returns the URI for a given token ID.
     * If a specific URI is set for the token ID, it's returned.
     * Otherwise, if a base URI is set, it constructs the URI as baseURI + tokenId.toString().
     * If neither is set, returns an empty string.
     */
    function uri(uint256 tokenId) public view virtual override returns (string memory) {
        string memory specificURI = _tokenURIs[tokenId];
        if (bytes(specificURI).length > 0) {
            return specificURI;
        }
        if (bytes(_baseURI).length > 0) {
            return string(abi.encodePacked(_baseURI, Strings.toString(tokenId)));
            // Consider adding a ".json" suffix or other patterns if needed:
            // return string(abi.encodePacked(_baseURI, Strings.toString(tokenId), ".json"));
        }
        return "";
    }

    /**
     * @dev Mints `amount` new tokens of `id` and assigns them to `to`.
     * Can optionally include `data`.
     * Emits a {TransferSingle} event.
     * Requirements:
     * - The caller must be the owner of the contract.
     * - `to` cannot be the zero address.
     * @param to The address to mint the NFTs to.
     * @param id The ID of the token type to mint.
     * @param amount The quantity of tokens of type `id` to mint.
     * @param data Optional data to pass along with the minting.
     */
    function mint(address to, uint256 id, uint256 amount, bytes memory data) public onlyOwner {
        _mint(to, id, amount, data);
    }

    /**
     * @dev Mints multiple new token types or amounts and assigns them.
     * Emits {TransferBatch} events.
     * Requirements:
     * - The caller must be the owner of the contract.
     * - `to` cannot be the zero address.
     * - `ids` and `amounts` arrays must have the same length.
     * @param to The address to mint the NFTs to.
     * @param ids Array of token IDs to mint.
     * @param amounts Array of amounts for each token ID.
     * @param data Optional data to pass along with the minting.
     */
    function mintBatch(address to, uint256[] memory ids, uint256[] memory amounts, bytes memory data) public onlyOwner {
        _mintBatch(to, ids, amounts, data);
    }
    
    /**
     * @dev Sets or updates the URI for a specific token ID.
     * Only callable by the contract owner.
     * This is useful if the global `_baseURI` is not used or needs to be overridden for specific tokens.
     * @param tokenId The ID of the token to update.
     * @param tokenURI_ The new URI for the token's metadata.
     */
    function setTokenURI(uint256 tokenId, string memory tokenURI_) public onlyOwner {
        _tokenURIs[tokenId] = tokenURI_;
        emit URI(tokenURI_, tokenId); // ERC1155 standard event
    }

    /**
     * @dev Sets or updates the base URI for the entire collection.
     * Only callable by the contract owner.
     * @param baseURI_ The new base URI.
     */
    function setBaseURI(string memory baseURI_) public onlyOwner {
        _baseURI = baseURI_;
    }

    /**
     * @dev See {IERC165-supportsInterface}.
     */
    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC1155, IERC165) returns (bool) {
        return interfaceId == type(IERC2981).interfaceId || super.supportsInterface(interfaceId);
    }

    /**
     * @dev See {IERC2981-royaltyInfo}.
     * Calculates royalty information for a given token ID and sale price.
     * @param tokenId The ID of the token being sold (unused in this version as royalty is collection-wide).
     * @param salePrice The price the token is being sold for.
     * @return receiver The address that should receive royalties.
     * @return royaltyAmount The royalty amount calculated for the sale price.
     */
    function royaltyInfo(
        uint256 tokenId,
        uint256 salePrice
    ) public view virtual override returns (address receiver, uint256 royaltyAmount) {
        (tokenId); // Suppress unused variable warning
        receiver = _royaltyRecipient;
        royaltyAmount = (salePrice * _royaltyFraction) / 10000;
        return (receiver, royaltyAmount);
    }
    
    /**
     * @dev Sets the royalty information for the entire collection.
     * Only callable by the contract owner.
     * @param royaltyRecipient_ New address to receive royalty payments.
     * @param royaltyPercentage_ New royalty percentage in basis points.
     */
    function setRoyaltyInfo(address royaltyRecipient_, uint96 royaltyPercentage_) public onlyOwner {
        require(royaltyRecipient_ != address(0), "ERC2981: Recipient is zero address");
        require(royaltyPercentage_ <= 10000, "ERC2981: Royalty percentage too high");
        _royaltyRecipient = royaltyRecipient_;
        _royaltyFraction = royaltyPercentage_;
    }

    // The following functions are overrides required by Solidity due to inheritance.
    function _beforeTokenTransfer(
        address operator,
        address from,
        address to,
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory data
    ) internal virtual override(ERC1155, ERC1155Supply) {
        super._beforeTokenTransfer(operator, from, to, ids, amounts, data);
    }
    
    // Ownable's transferOwnership and renounceOwnership are inherited.
}

// BlockDeploy Generation Placeholders:
// 1. {{LICENSE}}: SPDX License Identifier (e.g., MIT).
// 2. {{COLLECTION_NAME}}: Name of the NFT collection (used for context, not directly in ERC1155 constructor).
// 3. {{COLLECTION_SYMBOL}}: Symbol for the collection (used for context).
// 4. {{COLLECTION_CONTRACT_NAME}}: Solidity contract name, derived from COLLECTION_NAME.
// 5. {{INITIAL_OWNER_ADDRESS}}: Address of the user deploying this collection contract.
// 6. {{ROYALTY_RECIPIENT_ADDRESS}}: Address to receive royalty fees.
// 7. {{ROYALTY_PERCENTAGE_BPS}}: Royalty fee in basis points (e.g., 500 for 5%).
// 8. {{BASE_URI}}: Base URI for token metadata (e.g., "ipfs://YOUR_CID_HERE/"). If empty, individual URIs must be set.
//
// Notes for BlockDeploy implementation:
// - The `mint` and `mintBatch` functions are owner-only.
// - The `uri` function logic allows for a global base URI (e.g., for a collection where metadata is stored as `BASE_URI/{id}.json`) 
//   or specific URIs per token ID if `setTokenURI` is used. BlockDeploy UI should allow user to choose.
// - `setBaseURI` and `setTokenURI` allow the owner to manage metadata URIs post-deployment.
// - `ERC1155Supply` is included for on-chain supply tracking, which can be useful but adds gas.
//   Consider making its inclusion optional based on user choice.
```
