```solidity
// SPDX-License-Identifier: {{LICENSE}}

pragma solidity ^0.8.20;

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"; // For safe ERC20 transfers
import "@openzeppelin/contracts/utils/Address.sol"; // For isContract, sendValue

/**
 * @title SimpleTreasury
 * @dev A simple contract to hold ETH and ERC20 tokens for a DAO.
 * All fund transfers out of this treasury must be initiated by the owner
 * (intended to be a TimelockController contract controlled by the DAO's Governor).
 * Generated by BlockDeploy (Primex Software - https://primex-software.com).
 */
contract {{TREASURY_CONTRACT_NAME}} {
    using SafeERC20 for IERC20;
    using Address for address payable;

    address public owner; // Set to the TimelockController address

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
    event EtherReceived(address indexed sender, uint256 amount);
    event ERC20Received(address indexed sender, address indexed tokenContract, uint256 amount);
    event EtherTransferred(address indexed recipient, uint256 amount);
    event ERC20Transferred(address indexed recipient, address indexed tokenContract, uint256 amount);

    modifier onlyOwner() {
        require(msg.sender == owner, "SimpleTreasury: Caller is not the owner");
        _;
    }

    /**
     * @dev Sets the initial owner of the Treasury.
     * @param initialOwner The address of the TimelockController that will own this Treasury.
     */
    constructor(address initialOwner) {
        require(initialOwner != address(0), "SimpleTreasury: Initial owner is zero address");
        owner = initialOwner;
        emit OwnershipTransferred(address(0), initialOwner);
    }

    /**
     * @dev Allows the Treasury to receive Ether.
     */
    receive() external payable {
        emit EtherReceived(msg.sender, msg.value);
    }

    /**
     * @dev Allows the owner (TimelockController) to transfer Ether out of the Treasury.
     * @param recipient The address to receive the Ether.
     * @param amount The amount of Ether to send (in WEI).
     */
    function transferEther(address payable recipient, uint256 amount) external onlyOwner {
        require(recipient != address(0), "SimpleTreasury: Recipient is zero address");
        require(address(this).balance >= amount, "SimpleTreasury: Insufficient Ether balance");
        recipient.sendValue(amount); // Uses OpenZeppelin's Address.sendValue for safer transfer
        emit EtherTransferred(recipient, amount);
    }

    /**
     * @dev Allows the owner (TimelockController) to transfer ERC20 tokens out of the Treasury.
     * @param tokenContract The address of the ERC20 token contract.
     * @param recipient The address to receive the tokens.
     * @param amount The amount of tokens to send (in token's smallest unit).
     */
    function transferERC20(address tokenContract, address recipient, uint256 amount) external onlyOwner {
        require(tokenContract != address(0), "SimpleTreasury: Token contract is zero address");
        require(recipient != address(0), "SimpleTreasury: Recipient is zero address");
        IERC20 token = IERC20(tokenContract);
        // No need to check balance explicitly here, SafeERC20.safeTransfer will revert if insufficient.
        token.safeTransfer(recipient, amount);
        emit ERC20Transferred(recipient, tokenContract, amount);
    }

    /**
     * @dev Allows the owner to change the owner of this Treasury.
     * Should typically not be used if the Timelock is the permanent owner,
     * unless there's a DAO upgrade mécanisme.
     * @param newOwner The address of the new owner.
     */
    function transferOwnership(address newOwner) external onlyOwner {
        require(newOwner != address(0), "SimpleTreasury: New owner is zero address");
        emit OwnershipTransferred(owner, newOwner);
        owner = newOwner;
    }

    /**
     * @dev Fallback function to also accept Ether if sent directly without data.
     */
    // fallback() external payable {
    //     emit EtherReceived(msg.sender, msg.value);
    // }
    // Note: `receive()` is preferred over `fallback()` for simple ETH receipt.
    // If both are present, `receive()` is called for empty calldata, `fallback()` for non-empty.

    // Optional: Function to allow owner to "sweep" or rescue mistakenly sent ERC20 tokens
    // (tokens other than the ones intended for specific transfers).
    // This is useful if users accidentally send tokens to this Treasury contract.
    // function sweepERC20(address tokenContract, address recipient) external onlyOwner {
    //     require(tokenContract != address(0), "SimpleTreasury: Token contract is zero address");
    //     require(recipient != address(0), "SimpleTreasury: Recipient is zero address");
    //     IERC20 token = IERC20(tokenContract);
    //     uint256 balance = token.balanceOf(address(this));
    //     if (balance > 0) {
    //         token.safeTransfer(recipient, balance);
    //         emit ERC20Transferred(recipient, tokenContract, balance); // Could be a different event like ERC20Swept
    //     }
    // }
}

// BlockDeploy Generation Placeholders:
// 1. {{LICENSE}}: SPDX License Identifier (e.g., MIT).
// 2. {{TREASURY_CONTRACT_NAME}}: Solidity contract name (e.g., MyDAOTreasury).
// 3. {{TIMELOCK_CONTROLLER_ADDRESS}}: The address of the DAO's TimelockController contract,
//    which will be set as the `initialOwner` of this Treasury.
//
// Notes for BlockDeploy implementation:
// - This is a very basic Treasury. Its primary security relies on the `onlyOwner` modifier,
//   where the `owner` is intended to be the TimelockController contract of the DAO.
// - All operations 얼굴the Treasury (like spending funds) must be proposed and passed
//   through the DAO's governance process (Governor + Timelock).
// - The TimelockController would call `transferEther` or `transferERC20` on this Treasury
//   as part of executing a successful governance proposal.
// - Funding: ETH can be sent directly to this contract's address. ERC20 tokens must be
//   transferred to this contract's address using the standard ERC20 `transfer` function.
// - `SafeERC20.safeTransfer` is used for ERC20 transfers to prevent issues with tokens that
//   do not return a boolean or revert on failure.
// - `Address.sendValue` is used for ETH transfers as a safer alternative to `recipient.transfer(amount)`.
// - The `transferOwnership` function is included. In a typical DAO setup, the Timelock should remain
//   the owner. This function might be called by the Timelock itself if a proposal to change
//   the Treasury's ownership structure is passed by the DAO.
// - A `sweepERC20` function is commented out but could be useful for DAOs to recover tokens
//   accidentally sent to the treasury address. Its inclusion should be an option.
```
