```solidity
// SPDX-License-Identifier: {{LICENSE}}

pragma solidity ^0.8.20;

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/utils/math/SafeMath.sol"; // Or use Solidity 0.8+ checked arithmetic

/**
 * @title TokenVesting
 * @dev A token holder contract that can release its token balance gradually like a
 * typical vesting scheme, with a cliff and vesting period.
 * Tokens are locked in this contract and can be released to the beneficiary.
 * Generated by BlockDeploy (Primex Software - https://primex-software.com).
 */
contract {{VESTING_CONTRACT_NAME}} is Ownable {
    using SafeMath for uint256; // Remove if using Solidity 0.8+ default checked arithmetic

    IERC20 public immutable token; // ERC20 token that is being vested

    address public immutable beneficiary; // Address of the token recipient
    uint256 public immutable cliffDurationSeconds; // Duration of the cliff in seconds
    uint256 public immutable vestingDurationSeconds; // Total duration of vesting in seconds (after cliff)
    
    uint256 public immutable vestingStartTime; // Timestamp when the vesting schedule starts (typically deployment time or cliff start)
    uint256 public immutable totalVestingAmount; // Total amount of tokens to be vested

    uint256 public releasedAmount; // Amount of tokens already released

    event TokensReleased(address indexed beneficiary, uint256 amount);
    event VestingScheduleCreated(
        address indexed beneficiary,
        uint256 totalAmount,
        uint256 startTime,
        uint256 cliffDuration,
        uint256 vestingDuration
    );

    /**
     * @dev Creates a vesting contract.
     * @param _tokenAddress The address of the ERC20 token to be vested.
     * @param _beneficiary The Aaddress of the beneficiary of the vested tokens.
     * @param _vestingStartTime The Unix timestamp for the start of the vesting period (cliff starts from here).
     * @param _cliffDurationSeconds The duration in seconds of the cliff period (no tokens releasable).
     * @param _vestingDurationSeconds The total duration in seconds of the vesting period (linear release after cliff).
     * @param _totalVestingAmount The total amount of tokens to be vested (in token's smallest unit).
     * @param _initialOwner The owner of this vesting contract (typically the one setting up the vesting).
     */
    constructor(
        address _tokenAddress,
        address _beneficiary,
        uint256 _vestingStartTime,
        uint256 _cliffDurationSeconds,
        uint256 _vestingDurationSeconds,
        uint256 _totalVestingAmount,
        address _initialOwner
    ) Ownable(_initialOwner) {
        require(_tokenAddress != address(0), "TokenVesting: Token address is zero");
        require(_beneficiary != address(0), "TokenVesting: Beneficiary is zero address");
        require(_vestingDurationSeconds > 0, "TokenVesting: Vesting duration must be > 0");
        require(_totalVestingAmount > 0, "TokenVesting: Total vesting amount must be > 0");
        // Cliff can be 0. Vesting start time should be now or in the future.
        require(_vestingStartTime >= block.timestamp || owner() == msg.sender, "TokenVesting: Start time in past (unless owner deploying)");


        token = IERC20(_tokenAddress);
        beneficiary = _beneficiary;
        vestingStartTime = _vestingStartTime;
        cliffDurationSeconds = _cliffDurationSeconds;
        vestingDurationSeconds = _vestingDurationSeconds;
        totalVestingAmount = _totalVestingAmount;

        emit VestingScheduleCreated(
            _beneficiary,
            _totalVestingAmount,
            _vestingStartTime,
            _cliffDurationSeconds,
            _vestingDurationSeconds
        );
    }

    /**
     * @dev Calculates the amount of tokens that have vested at the current time.
     * @return The amount of vested tokens (in token's smallest unit).
     */
    function getVestedAmount() public view returns (uint256) {
        if (block.timestamp < vestingStartTime + cliffDurationSeconds) {
            return 0; // Before cliff ends, nothing is vested
        }

        if (block.timestamp >= vestingStartTime + cliffDurationSeconds + vestingDurationSeconds) {
            return totalVestingAmount; // After vesting period ends, all tokens are vested
        }

        // During vesting period (after cliff)
        uint256 timeElapsedSinceCliffEnd = block.timestamp - (vestingStartTime + cliffDurationSeconds);
        // Vested amount = (totalVestingAmount * timeElapsedSinceCliffEnd) / vestingDurationSeconds
        // This calculates tokens vested *after* the cliff has passed, for the duration of `vestingDurationSeconds`.
        return totalVestingAmount.mul(timeElapsedSinceCliffEnd).div(vestingDurationSeconds);
    }

    /**
     * @dev Calculates the amount of tokens that are releasable to the beneficiary at the current time.
     * This is the vested amount minus what has already been released.
     * @return The amount of releasable tokens.
     */
    function getReleasableAmount() public view returns (uint256) {
        return getVestedAmount().sub(releasedAmount);
    }

    /**
     * @dev Allows the beneficiary to release vested tokens.
     * Transfers vested tokens to the beneficiary.
     */
    function release() external nonReentrant {
        require(msg.sender == beneficiary || msg.sender == owner(), "TokenVesting: Not authorized to release");
        
        uint256 releasable = getReleasableAmount();
        require(releasable > 0, "TokenVesting: No tokens available for release");

        releasedAmount = releasedAmount.add(releasable);
        
        // Ensure this contract holds enough tokens
        require(token.balanceOf(address(this)) >= releasable, "TokenVesting: Insufficient token balance in contract");
        require(token.transfer(beneficiary, releasable), "TokenVesting: Token transfer failed");

        emit TokensReleased(beneficiary, releasable);
    }
    
    /**
     * @dev Allows the owner to revoke the vesting schedule for a non-revocable beneficiary (e.g. if employee leaves).
     * Any unvested tokens are returned to the owner. This is a common feature but makes the vesting "soft".
     * For a "hard" vesting, this function should not exist or be more restricted.
     * This function is OPTIONAL and depends on desired behavior. For MVP, it might be excluded for simplicity,
     * or included if revocability is a key requirement.
     * For this template, we include a simple version.
     * Consider if cliff affects revocable amount. Typically, anything not vested is revocable.
     */
    // function revoke() external onlyOwner {
    //     require(block.timestamp < vestingStartTime + cliffDurationSeconds + vestingDurationSeconds, "TokenVesting: Vesting period already completed");
        
    //     uint256 vested = getVestedAmount();
    //     uint256 unreleasedVested = vested.sub(releasedAmount);
    //     uint256 nonVested = totalVestingAmount.sub(vested);
        
    //     // Transfer any unreleased vested tokens to beneficiary first
    //     if (unreleasedVested > 0) {
    //         require(token.transfer(beneficiary, unreleasedVested), "TokenVesting: Transfer of vested tokens failed during revoke");
    //         releasedAmount = releasedAmount.add(unreleasedVested);
    //     }
        
    //     // Transfer all remaining (non-vested) tokens back to owner
    //     uint256 remainingInContract = token.balanceOf(address(this)); // Should be totalVestingAmount - releasedAmount
    //     if (remainingInContract > 0) { // This should be equal to nonVested if contract was funded correctly
    //          require(token.transfer(owner(), remainingInContract), "TokenVesting: Transfer of non-vested tokens failed during revoke");
    //     }
        
    //     // Effectively ends the vesting schedule by setting totalVestingAmount to what has been released (or vested)
    //     // totalVestingAmount = releasedAmount; // Or totalVestingAmount = vested;
    //     // This makes future calls to getVestedAmount() or getReleasableAmount() reflect the revocation.
    //     // A simpler revocation might just pull all unreleased tokens and zero out `totalVestingAmount` and `releasedAmount`.
    //     // For MVP, a more complex revoke might be out of scope.
    //     // A simple revoke: transfer all contract balance back to owner, and beneficiary can't claim more.
    //     // This means beneficiary loses unreleased but vested tokens. This is harsh.
    //     //
    //     // Let's simplify: Revoke means any tokens NOT YET VESTED are returned to owner.
    //     // Beneficiary can still claim what was vested up to revocation point.
    //     // This requires changing `totalVestingAmount` to `vestedAmountAtRevocation`.
    //     // This is complex. For MVP, a "hard" vesting (non-revocable by owner) is simpler.
    //     // If revocable is needed, it's usually for specific cases like employee vesting.
    //     // This template will NOT include `revoke()` for MVP simplicity, assuming hard vesting.
    // }


    // Fallback to prevent accidental ETH sends to this contract
    receive() external payable {
        revert("TokenVesting: This contract does not accept ETH");
    }
}

// BlockDeploy Generation Placeholders & Notes:
// 1.  {{LICENSE}}: SPDX License Identifier (e.g., MIT).
// 2.  {{VESTING_CONTRACT_NAME}}: Solidity contract name (e.g., MyProjectTeamVesting).
// 3.  {{TOKEN_ADDRESS}}: Address of the ERC20 token being vested.
// 4.  {{BENEFICIARY_ADDRESS}}: Address of the recipient of the vested tokens.
// 5.  {{VESTING_START_TIME_UNIX}}: Unix timestamp for when vesting calculations begin.
// 6.  {{CLIFF_DURATION_SECONDS}}: Duration of the cliff in seconds from `VESTING_START_TIME_UNIX`.
// 7.  {{VESTING_DURATION_SECONDS}}: Total duration of the vesting period in seconds, *after* the cliff.
//     So, full vesting completes at `VESTING_START_TIME_UNIX + CLIFF_DURATION_SECONDS + VESTING_DURATION_SECONDS`.
// 8.  {{TOTAL_VESTING_AMOUNT_SMALLEST_UNIT}}: Total amount of tokens to be vested, in token's smallest unit.
// 9.  {{INITIAL_OWNER_ADDRESS}}: Address of the entity setting up and owning this vesting contract (can change admin functions).
//
// Pre-requisites for Project Owner before deploying this vesting contract:
// - The ERC20 token ({{TOKEN_ADDRESS}}) must exist.
// - The entity deploying/funding this vesting contract must transfer {{TOTAL_VESTING_AMOUNT_SMALLEST_UNIT}}
//   of the token to THIS Vesting Contract's address AFTER it's deployed.
//   BlockDeploy UI must guide the user to fund the vesting contract with the tokens.
//
// The `release` function can be called by the beneficiary or the owner. This allows the owner to trigger
// a release on behalf of the beneficiary if needed, or for automated scripts.
//
// Revocability: This template currently implements a "hard" vesting (non-revocable by owner for unvested portions
// once set up and funded). If revocability is a desired feature, a `revoke()` function with clear rules
// on how unvested and unreleased-but-vested tokens are handled would need to be added. This adds complexity
// and should be a deliberate design choice. For MVP, non-revocable is simpler and often preferred for
// investor/community vesting to build trust.
```
