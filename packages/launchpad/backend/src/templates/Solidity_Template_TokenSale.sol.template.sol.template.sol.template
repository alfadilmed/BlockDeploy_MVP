```solidity
// SPDX-License-Identifier: {{LICENSE}}

pragma solidity ^0.8.20;

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/utils/math/SafeMath.sol"; // Or use Solidity 0.8+ checked arithmetic
import "@openzeppelin/contracts/security/ReentrancyGuard.sol";

/**
 * @title TokenSale_FixedPrice
 * @dev Contract for a fixed-price token sale (IDO style).
 * Allows whitelisted users to buy a specific ERC20 token using native currency (ETH).
 * Generated by BlockDeploy (Primex Software - https://primex-software.com).
 *
 * Features:
 *  - Fixed price for tokens.
 *  - Hard cap on total tokens to be sold.
 *  - Sale period (start and end times).
 *  - Minimum and maximum contribution per participant.
 *  - Whitelisting of participants.
 *  - Owner can withdraw funds and unsold tokens.
 */
contract {{SALE_CONTRACT_NAME}} is Ownable, ReentrancyGuard {
    using SafeMath for uint256; // Remove if using Solidity 0.8+ default checked arithmetic

    IERC20 public immutable tokenBeingSold; // The ERC20 token being sold
    // address public immutable paymentToken; // For MVP, using native currency (ETH). Future: ERC20 payment.

    uint256 public immutable tokenPrice; // Price of one token unit (e.g., in WEI if payment is ETH)
                                        // Example: If 1 TOKEN = 0.001 ETH, tokenPrice = 0.001 * 10^18 / (10^tokenDecimals)
                                        // Or, more simply, price for the smallest unit of the token in WEI.
                                        // If token has 18 decimals, price of 1 full token in WEI.

    uint256 public immutable saleStartTime;
    uint256 public immutable saleEndTime;

    uint256 public immutable minInvestmentPerUser; // Minimum purchase amount in payment currency (WEI)
    uint256 public immutable maxInvestmentPerUser; // Maximum purchase amount in payment currency (WEI)
    
    uint256 public immutable totalTokensForSale;   // Total amount of tokens allocated for this sale
    uint256 public tokensSold;                     // Total tokens sold so far
    uint256 public fundsRaised;                    // Total funds raised in payment currency (WEI)

    mapping(address => uint256) public contributions; // How much each user has spent (in WEI)
    mapping(address => bool) public whitelist;      // Whitelisted addresses

    address payable public fundCollectionWallet;   // Wallet to receive raised funds

    event TokensPurchased(address indexed buyer, uint256 amountPaid, uint256 tokensReceived);
    event SaleFinalized(uint256 totalFundsRaised, uint256 totalTokensSold, uint256 unsoldTokensReturned);
    event WhitelistUpdated(address[] users, bool status);

    modifier onlyWhitelisted() {
        require(whitelist[msg.sender], "TokenSale: Caller is not whitelisted");
        _;
    }

    modifier saleActive() {
        require(block.timestamp >= saleStartTime, "TokenSale: Sale has not started");
        require(block.timestamp < saleEndTime, "TokenSale: Sale has ended");
        _;
    }

    modifier saleNotActiveOrEnded() {
        require(block.timestamp < saleStartTime || block.timestamp >= saleEndTime, "TokenSale: Sale is currently active");
        _;
    }
    
    modifier saleEnded() {
        require(block.timestamp >= saleEndTime, "TokenSale: Sale has not ended yet");
        _;
    }

    /**
     * @param _tokenBeingSold Address of the ERC20 token to be sold.
     * @param _tokenPrice Price for one unit of the tokenBeingSold, in WEI (if paying with ETH).
     *                    Ensure this price accounts for the decimals of _tokenBeingSold.
     *                    E.g., if token has 18 decimals and price is 0.001 ETH per token, _tokenPrice = 10^15.
     * @param _totalTokensForSale Total amount of tokens (in their smallest unit, e.g., wei-equivalent for 18 decimals) available for this sale.
     * @param _saleStartTime Unix timestamp for when the sale starts.
     * @param _saleEndTime Unix timestamp for when the sale ends.
     * @param _minInvestmentPerUser Minimum investment in WEI.
     * @param _maxInvestmentPerUser Maximum investment in WEI.
     * @param _fundCollectionWallet Address to receive collected ETH.
     * @param _initialOwner Owner of this sale contract.
     */
    constructor(
        address _tokenBeingSold,
        uint256 _tokenPrice, // Price for one whole token unit if token has 18 decimals.
        uint256 _totalTokensForSale, // Amount in token's smallest unit.
        uint256 _saleStartTime,
        uint256 _saleEndTime,
        uint256 _minInvestmentPerUser,
        uint256 _maxInvestmentPerUser,
        address payable _fundCollectionWallet,
        address _initialOwner
    ) Ownable(_initialOwner) {
        require(_tokenBeingSold != address(0), "TokenSale: Token address is zero");
        require(_tokenPrice > 0, "TokenSale: Token price must be > 0");
        require(_totalTokensForSale > 0, "TokenSale: totalTokensForSale must be > 0");
        require(_saleEndTime > _saleStartTime, "TokenSale: End time must be after start time");
        require(_maxInvestmentPerUser >= _minInvestmentPerUser, "TokenSale: Max investment < min investment");
        require(_fundCollectionWallet != address(0), "TokenSale: Fund wallet is zero address");

        tokenBeingSold = IERC20(_tokenBeingSold);
        tokenPrice = _tokenPrice;
        totalTokensForSale = _totalTokensForSale;
        saleStartTime = _saleStartTime;
        saleEndTime = _saleEndTime;
        minInvestmentPerUser = _minInvestmentPerUser;
        maxInvestmentPerUser = _maxInvestmentPerUser;
        fundCollectionWallet = _fundCollectionWallet;
    }

    /**
     * @dev Allows users to buy tokens during an active sale.
     * User must be whitelisted and send ETH (msg.value).
     */
    function buyTokens() external payable nonReentrant saleActive onlyWhitelisted {
        uint256 paymentAmount = msg.value;
        require(paymentAmount >= minInvestmentPerUser, "TokenSale: Payment below minimum investment");
        
        uint256 currentContribution = contributions[msg.sender];
        require(currentContribution.add(paymentAmount) <= maxInvestmentPerUser, "TokenSale: Exceeds max investment per user");

        // Calculate tokens to buy. tokenPrice is for one whole token unit.
        // If tokenPrice is for the smallest unit (like wei for an 18-decimal token), then calculation is direct.
        // Assuming tokenPrice is for one whole token unit (e.g., 1 TOKEN = 0.001 ETH, tokenPrice = 10^15 for 18dec token)
        // And paymentAmount is in WEI.
        // tokensToReceive = paymentAmount / tokenPrice (if tokenPrice is per smallest unit)
        // tokensToReceive = (paymentAmount * (10^tokenDecimals)) / tokenPrice (if tokenPrice is per whole token, and paymentAmount is for whole tokens)
        // For simplicity, assume tokenPrice is for the smallest unit of the token.
        // If token has D decimals, and 1 full token costs P ETH, then tokenPrice = P * 10^18 / 10^D.
        // If BlockDeploy UI asks for "Price per Token (ETH)" and "Token Decimals", then backend calculates this `_tokenPrice`.
        // Let's assume `tokenPrice` is correctly set by constructor (price in WEI for the smallest unit of the token)
        // uint256 tokensToReceive = paymentAmount.mul(10**uint256(tokenBeingSold.decimals())).div(tokenPrice); // If tokenPrice is for 1 full token in ETH
        // If tokenPrice is price in WEI for one "atomic unit" of the token:
        uint256 tokensToReceive = paymentAmount.div(tokenPrice); 
        // This implies `_tokenPrice` in constructor was "WEI per atomic unit of token".
        // E.g. if 1 full token (10^18 units) costs 0.001 ETH (10^15 WEI), then 1 atomic unit costs 10^15 / 10^18 = 10^-3 WEI. This is problematic.
        //
        // Let's redefine: tokenPrice = WEI per WHOLE token.
        // User sends ETH (msg.value).
        // tokensToReceive (in atomic units) = (msg.value * 10^tokenDecimals) / tokenPriceInWeiForOneWholeToken
        //
        // To keep it simple for the template, let's assume the UI/backend calculates `_tokenPrice` such that:
        // `tokensToReceive = paymentAmount / _tokenPrice` where `tokensToReceive` is in atomic units.
        // This means `_tokenPrice` must be "WEI per atomic unit of token".
        // Example: Token A (18 dec). 1 A = 0.1 ETH.
        // _tokenPrice = (0.1 * 10^18 WEI) / (1 * 10^18 atomic units) = 0.1 WEI per atomic unit (Incorrect, should be 1 WEI per atomic unit if price is 10^18 for 10^18 units)
        // If 1 Token (10^18 units) costs 0.1 ETH (10^17 Wei)
        // Then _tokenPrice (WEI for 1 atomic unit) = 10^17 / 10^18 = 0.1 WEI. This is not possible with integers.
        //
        // SAFER: _tokenPrice is WEI for 1 WHOLE token.
        // uint8 tokenDecimals = IERC20Metadata(address(tokenBeingSold)).decimals(); // Get decimals if contract supports it
        // uint256 tokensToReceive = paymentAmount.mul(10**tokenDecimals).div(tokenPrice);
        // For MVP, assume tokenDecimals is a known constant (e.g. 18) or passed to constructor for this calculation if needed.
        // For this template, we'll assume `tokenPrice` is the amount of WEI for **one** unit of `tokenBeingSold` (smallest denomination).
        // This means the UI/backend needs to calculate this carefully.
        // If 1 full token (10^D units) costs P ETH, then 1 atomic unit costs (P * 10^18 / 10^D) WEI.
        // For this template, let's assume `tokenPrice` is price in WEI for 1 WHOLE TOKEN (e.g. if token has 18 decimals, price for 10^18 units of it)
        // And the user is buying X WHOLE TOKENS. But user sends ETH.
        // This calculation is critical. The `Crowdsale.sol` from OpenZeppelin has `_rate`: number of token units a buyer gets per wei.
        // `uint256 tokenAmount = msg.value.mul(_rate);`
        // If we use `tokenPrice` as "WEI per 1 token (smallest unit)", then:
        // `uint256 tokensToReceive = paymentAmount / tokenPrice;` is correct.
        // This `tokenPrice` must be calculated by BlockDeploy backend: `(priceInEthForOneWholeToken * 10^18) / (10^tokenDecimals)`
        // Let's assume `tokenPrice` is for 1 whole token. So `tokensToReceive = (paymentAmount * 10^tokenDecimals) / tokenPrice`
        // For simplicity, the template will assume `tokenPrice` is for the smallest unit of the token.
        // BlockDeploy backend job: _tokenPrice = (priceEthPerWholeToken * 10^18) / (10^token_decimals)
        uint256 tokensToReceive = paymentAmount.div(tokenPrice); // Amount in token's smallest unit

        require(tokensSold.add(tokensToReceive) <= totalTokensForSale, "TokenSale: Not enough tokens left for sale");

        contributions[msg.sender] = currentContribution.add(paymentAmount);
        tokensSold = tokensSold.add(tokensToReceive);
        fundsRaised = fundsRaised.add(paymentAmount);

        // Transfer tokens to buyer
        // The sale contract must hold the tokens. Project owner needs to transfer `totalTokensForSale` to this contract first.
        require(tokenBeingSold.transfer(msg.sender, tokensToReceive), "TokenSale: Token transfer failed");

        emit TokensPurchased(msg.sender, paymentAmount, tokensToReceive);
    }

    /**
     * @dev Adds or removes addresses from the whitelist. Only callable by the owner.
     * @param _users Array of user addresses.
     * @param _isWhitelisted Boolean status to set for these users.
     */
    function updateWhitelist(address[] calldata _users, bool _isWhitelisted) external onlyOwner {
        for (uint i = 0; i < _users.length; i++) {
            whitelist[_users[i]] = _isWhitelisted;
        }
        emit WhitelistUpdated(_users, _isWhitelisted);
    }

    /**
     * @dev Allows the owner to withdraw raised funds (ETH) after the sale has ended.
     */
    function withdrawFunds() external onlyOwner saleEnded nonReentrant {
        uint256 amountToWithdraw = address(this).balance;
        require(amountToWithdraw > 0, "TokenSale: No funds to withdraw");
        // solhint-disable-next-line indent
        (bool success, ) = fundCollectionWallet.call{value: amountToWithdraw}("");
        require(success, "TokenSale: Fund withdrawal failed");
    }

    /**
     * @dev Allows the owner to reclaim unsold tokens after the sale has ended.
     */
    function reclaimUnsoldTokens() external onlyOwner saleEnded nonReentrant {
        uint256 unsoldTokens = totalTokensForSale.sub(tokensSold);
        if (unsoldTokens > 0) {
            // Ensure this contract still has the unsold tokens
            require(tokenBeingSold.balanceOf(address(this)) >= unsoldTokens, "TokenSale: Insufficient contract token balance for reclaim");
            require(tokenBeingSold.transfer(owner(), unsoldTokens), "TokenSale: Unsold token reclaim failed");
        }
        emit SaleFinalized(fundsRaised, tokensSold, unsoldTokens);
    }

    /**
     * @dev Returns the amount of tokens remaining for sale.
     */
    function getTokensRemaining() public view returns (uint256) {
        return totalTokensForSale.sub(tokensSold);
    }

    /**
     * @dev Fallback function to receive ETH (not strictly necessary if buyTokens is the only way to send ETH).
     */
    receive() external payable {
        // Could redirect to buyTokens or revert. For MVP, let's keep it simple.
        // buyTokens(); // This would require buyTokens to not be onlyWhitelisted or handle it.
        // Reverting is safer if direct ETH sends are not intended for purchase.
        revert("TokenSale: Direct ETH transfers not accepted, use buyTokens()");
    }
}

// BlockDeploy Generation Placeholders & Notes:
// 1.  {{LICENSE}}: SPDX License Identifier (e.g., MIT).
// 2.  {{SALE_CONTRACT_NAME}}: Solidity contract name (e.g., MyProjectTokenSale).
// 3.  {{TOKEN_BEING_SOLD_ADDRESS}}: Address of the ERC20 token.
// 4.  {{TOKEN_PRICE_IN_WEI_PER_SMALLEST_UNIT}}: Calculated by backend.
//     Formula: (PriceInETHPerWholeToken * 10^18) / (10^TokenDecimals)
//     Example: Token XYZ (18 decimals), Price = 0.001 ETH / XYZ.
//     _tokenPrice = (0.001 * 10^18) / (10^18) = 1 * 10^15 WEI per smallest unit (1 XYZ unit).
//     If user sends 10^15 WEI (0.001 ETH), they get 1 token unit (10^18 of these make 1 full token).
//     This seems correct for: `tokensToReceive = paymentAmount.div(tokenPrice);`
//     The UI should display price per WHOLE token. Backend converts.
// 5.  {{TOTAL_TOKENS_FOR_SALE_IN_SMALLEST_UNIT}}: Total supply for sale in token's smallest denomination.
// 6.  {{SALE_START_TIME_UNIX}}: Unix timestamp.
// 7.  {{SALE_END_TIME_UNIX}}: Unix timestamp.
// 8.  {{MIN_INVESTMENT_WEI}}: Minimum ETH contribution in WEI.
// 9.  {{MAX_INVESTMENT_WEI}}: Maximum ETH contribution in WEI.
// 10. {{FUND_COLLECTION_WALLET_ADDRESS}}: Address where ETH raised will be sent.
// 11. {{INITIAL_OWNER_ADDRESS}}: Address of the project owner deploying the sale.
//
// Pre-requisites for Project Owner before deploying this sale contract:
// - The ERC20 token ({{TOKEN_BEING_SOLD_ADDRESS}}) must exist.
// - The Project Owner must transfer {{TOTAL_TOKENS_FOR_SALE_IN_SMALLEST_UNIT}} of this token
//   to THIS Sale Contract's address AFTER it's deployed, OR approve this sale contract
//   to spend that amount from their wallet. The current template assumes the tokens are
//   transferred TO the sale contract, and the sale contract then transfers them out.
//   This is a common pattern. The `tokenBeingSold.transfer` in `buyTokens` implies this.
//   BlockDeploy UI must guide the user to fund the sale contract with their project tokens.
```
